#!/usr/bin/env python3

import os.path as osp
import subprocess
import argparse

parser = argparse.ArgumentParser(prog="dots", description="synchronize my dot files")
parser.add_argument("-i", "--initial", action="store_true")
args = parser.parse_args()

HOME = "/home/gb/"
REPO = osp.join(HOME, "dots")
LIST = osp.join(REPO, "managed.txt")


def sync(managed, src, dst):
    """Synchronize files into and out of the repo"""
    files = []
    with open(managed, "rt") as fp:
        for line in fp:
            name = line.strip()
            if not name or name.startswith("#"):
                continue
            files.append(name)

    for file in files:
        spath = osp.join(src, file)
        dpath = osp.join(dst, file)
        if not osp.exists(spath):
            if osp.exists(dpath):
                print("not removing", dpath)
            continue
        if osp.isdir(spath) and not spath.endswith("/"):
            spath = spath + "/"
            dpath = dpath + "/"
        # print(f"rsync -a --delete {spath} {dpath}")
        subprocess.run(["rsync", "-a", "--delete", spath, dpath], check=True)


if not args.initial:
    # fetch files from the remote
    subprocess.run(["git", "fetch"], cwd=REPO, check=True)

    # copy the files from HOME into the REPO
    sync(LIST, HOME, REPO)

    # run nvim so I can manage the merge
    subprocess.run(["nvim", "-c", "G", "-c", "only"], cwd=REPO, check=True)

    # fetch files from the remote
    subprocess.run(["git", "push"], cwd=REPO, check=True)

# copy the files back out
if not osp.exists(osp.join(REPO, "stop")):
    sync(LIST, REPO, HOME)
else:
    print("did not deploy")
